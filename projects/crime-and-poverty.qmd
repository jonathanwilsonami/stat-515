---
title: "Possible Relationship Between Poverty & Crime in Dillon County South Carolina"
date: 2025-09-25
categories: [Data Viz]
repo-url: https://github.com/jonathanwilsonami/stat-515
format: html
authors: 
  - "Jonathan Wilson"
  - "Sean Reilly"
---

**Summary:** Data Visualization Redesign Project. 

::: {.badges}
**Tech Stack:** R, Python, Polars
:::

## Overview & Background 

Big Idea
- who, what 
what is the problem? 
hypothesis or solution offered what was done to validate this finding 
what are the findimgs 
what is the reco or call to action or final suggestin 


3 Min Story
- Background 
- Original chart 
- Data used 
- Overview of data fetching process 
- Call to action 

## Original Graphic

![The original chart[^refnote].](/images/old-chart-bubble-chart-crime.png){#fig-original fig-align="center" width="100%"}

[^refnote]: Gupta, A. (2022, February 23). 10 Good and Bad Examples of Data Visualization · Polymer. Polymer. https://www.polymersearch.com/blog/10-good-and-bad-examples-of-data-visualization

  The visualization shown above (see @fig-original) is the original graph that we chose for this redesign project. This visualization was taken from a website that identified multiple examples of data visualizations that do not follow best practices. Just at first glance, we can very quickly determine that there is a lot going on in this graph. In fact, there is too much going on to the point that it is hard for the audience to understand the intended story behind the graph. 

### The Good  

- The chart attempts to track three variables (property crime, violent crime, and poverty rate) in the same visualization which can be insightful to examine their intertwined relationships.
- Using bubble charts is actually not a bad idea here and when used well it can actually be insightful allowing for proportions to be distinguished. 

### The Bad
On the other hand the chart did not do a great job in portraying the data in such a way that the audience can easily interpret and did poorly is several areas:

- The bubble radius for the poverty variable has no numeric reference, so even though they are comparable between states, any single radius has no meaning on its own. 
- Additionally, there is no title of the graph so it is unclear what timeframe this data is coming from.
- The state labels are messy and hard to read
- The units could be more explicit.
- The color choice is not the best. 

Overall, there are several changes that can be made to this original graph to better illustrate the data and the message. 

## Our Proposed Redesign 

  In our redesigns, the primary goal is to make the visualizations easier to understand than the original graph. This entails reducing the level of effort needed to interpret the visualizations. There are some elements of the original graph that had good intentions behind them though, that are worth incorporating in our redesigns but we will also include several improvements and extensions to the original in several ways: 
  
- The concept of tracking three variables in the same visualization can be insightful to examine their intertwined relationships. However, we can implement this concept more effectively by simplifying variable visuals and reducing overall visual clutter within the graph. 
- Additionally, we can create multiple graphs side by side for comparison between these variables, with each graph focusing on only one or two variables. 
- For another example, the concept of comparing variables between states is important in telling a story about the data. However, we can implement this concept more effectively by cleaning up the state labels and even utilizing a different element, such as a color gradient, to differentiate between the multiple poverty levels. 
- Additionally, we can even move away from classic dot plots and explore plotting this data on a map, as most readers are familiar with a map of the US. 

These are just some of the various solutions that we implemented in our redesigns. 


```{r echo=FALSE, message=FALSE, warning=FALSE, error=FALSE}
# See renv.lock 
library(ggplot2)
library(dplyr)
# library(sf)
library(maps)
# library(stringr)
library(tidyr)
library(tidyverse) 
library(mapproj)
library(patchwork)
library(scales)
library(plotly)

##################################
# Data Sources 
##################################
state <- read.csv("data/crime_plus_poverty_2023.csv")
county <- read.csv("data/crime_poverty_by_county_2023.csv", check.names = FALSE)

##################################
# Data Cleaning 
##################################
# Droping rows where census data was not available for 2023 source county data 
if ("no_population" %in% names(county)) {
  county <- county %>% dplyr::filter(no_population != "true")
}

county <- county %>%
  mutate(
    poverty_rate = as.numeric(poverty_rate),
    property_crime_per_100k = as.numeric(property_crime_per_100k),
    violent_crime_per_100k = as.numeric(violent_crime_per_100k)
  )

##################################
# Useful functions & Vars
##################################
county_metric_cols <- c("poverty_rate",
            "property_crime_per_100k",
            "violent_crime_per_100k")

# Create geometries for mapping 
us_counties <- ggplot2::map_data("county")  # long/lat + region (state), subregion (county)
county_key  <- maps::county.fips %>% mutate(polyname = str_to_lower(polyname))

counties_poly <- us_counties %>%
  mutate(polyname = paste(region, subregion, sep = ",")) %>%
  left_join(county_key, by = "polyname") %>%
  rename(fips = fips) %>%
  filter(!is.na(fips))

# Function for creating maps
build_county_map <- function(data) {
  ggplot(data, aes(long, lat, group = group)) +
    geom_polygon(color = "gray85", linewidth = 0.1, na.rm = TRUE) +
    coord_quickmap() +
    theme_void(base_size = 12) +
    theme(
      legend.position = "bottom",
      plot.title = element_text(face = "bold", size = 16),
      plot.margin = margin(4, 8, 4, 8)
    )
}

# Helper to compute sensible upper limits (95th percentile) for crime and poverty rates 
p95 <- function(x) {
  x <- x[is.finite(x)]
  if (!length(x)) return(NA_real_)
  as.numeric(quantile(x, 0.95, na.rm = TRUE))
}

# Derive county FIPS given a data frame
# Uses: fips OR state+county codes OR state_abbr+county name
derive_fips <- function(df, county_key = NULL, keep_unmatched = FALSE) {
  stopifnot(is.data.frame(df))

  finish <- function(out) invisible(if (keep_unmatched) out else dplyr::filter(out, !is.na(.data$fips)))

  # county crosswalk (polyname = "state,county" lowercase)
  if (is.null(county_key)) {
    county_key <- maps::county.fips |>
      dplyr::mutate(polyname = stringr::str_to_lower(polyname))
  }

  # Already has FIPS
  if ("fips" %in% names(df)) {
    out <- dplyr::mutate(df, fips = stringr::str_pad(as.character(.data$fips), 5, "0"))
    return(finish(out))
  }

  # state + county numeric/string codes
  if (all(c("state", "county") %in% names(df))) {
    out <- dplyr::mutate(
      df,
      fips = paste0(
        stringr::str_pad(as.character(.data$state),  2, "0"),
        stringr::str_pad(as.character(.data$county), 3, "0")
      )
    )
    return(finish(out))
  }

  # state_abbr + county name (match via polyname)
  county_col <- c("county_name", "county")[c("county_name", "county") %in% names(df)][1]
  if (!is.na(county_col) && "state_abbr" %in% names(df)) {
    states_lookup <- tibble::tibble(
      state_abbr = c(state.abb, "DC"),
      state_name = c(state.name, "District of Columbia")
    ) |>
      dplyr::mutate(state_name_lower = stringr::str_to_lower(state_name))

    norm_county <- function(x) {
      x |>
        stringr::str_to_lower() |>
        stringr::str_replace_all("\\s+(county|parish|borough|census area|municipality|city)$", "") |> # Regex to extract county name
        stringr::str_replace_all("^st\\.?\\s", "saint ")
    }

    out <- df |>
      dplyr::left_join(states_lookup, by = "state_abbr") |>
      dplyr::mutate(polyname = paste(.data$state_name_lower, norm_county(.data[[county_col]]), sep = ",")) |>
      dplyr::left_join(county_key, by = "polyname")  # adds fips
    return(finish(out))
  }

  stop("derive_fips(): need one of: 'fips'; 'state'+'county'; or 'state_abbr'+county name.")
}

# Used to make the color scale look better 
scale_fill_binned_left <- function(
  x, # numeric vector used to size bins 
  step, # bin width 
  min_cap = NULL,
  max_cap = NULL,
  label_fmt = label_percent(accuracy = 1),
  name = NULL, # legend title
  option = "mako", begin = 0.15, end = 0.90, direction = -1,
  bar_width_mm = 200, bar_height_mm = 12,
  title_size = 13, label_size = 12,
  show_separators = TRUE  # draw white separators at bin edges
) {
  stopifnot(is.numeric(x), is.numeric(step), step > 0)

  # compute "nice" upper bound from p95, then clamp to caps if provided
  upper_raw <- ceiling(p95(x) / step) * step
  if (!is.null(min_cap)) upper_raw <- max(min_cap, upper_raw)
  if (!is.null(max_cap)) upper_raw <- min(max_cap, upper_raw)

  brks <- seq(0, upper_raw, by = step)
  labs <- paste0(label_fmt(head(brks, -1)), "–", label_fmt(tail(brks, -1)))
  labs <- c(labs, "")

  scale_fill_viridis_b(
    option = option, begin = begin, end = end, direction = direction,
    limits = range(brks),
    breaks = brks,
    labels = labs,
    oob = scales::squish, na.value = "gray95",
    name = name %||% "",
    guide = guide_colorsteps(
      title.position = "top",
      label.position = "top", # labels above bar
      label.theme  = element_text(size = label_size, hjust = 0),  # left-justify
      ticks = show_separators,
      ticks.colour = if (show_separators) "white" else NULL,
      ticks.linewidth = if (show_separators) 2 else NULL,
      show.limits = FALSE,
      barwidth  = grid::unit(bar_width_mm,  "mm"),
      barheight = grid::unit(bar_height_mm, "mm"),
      title.theme = element_text(size = title_size, face = "bold",
                                 margin = margin(b = 4))
    )
  )
}

`%||%` <- function(a, b) if (is.null(a)) b else a

# Formtter for plotly maps 
apply_plotly_binned_colorbar <- function(p, brks, labs, palette = "mako",
                                         begin = 0.15, end = 0.90, direction = -1,
                                         title = "Legend", horizontal = TRUE,
                                         thickness = 28, len = 1, show_separators = TRUE,
                                         title_font_size = 13, tick_font_size = 12) {
  cols <- viridisLite::mako(length(brks) - 1, begin = begin, end = end, direction = direction)

  # invisible heatmap solely to carry the colorbar
  p <- p %>%
    plotly::add_heatmap(
      z = matrix(seq(min(brks), max(brks), length.out = 2), nrow = 1),
      showscale = TRUE,
      colors = cols,
      hoverinfo = "skip",
      opacity = 0,
      xaxis = "x2", yaxis = "y2"
    ) %>%
    plotly::layout(
      xaxis2 = list(visible = FALSE, domain = c(0, 0.001), anchor = "y2", overlaying = "x"),
      yaxis2 = list(visible = FALSE, domain = c(0, 0.001), anchor = "x2", overlaying = "y")
    )

  idx <- length(p$x$data)
  p$x$data[[idx]]$colorbar <- list(
    title    = list(text = title, side = "top", font = list(size = title_font_size)),
    tickmode = "array",
    tickvals = brks,
    ticktext = c(labs, ""),  # empty label on rightmost edge
    ticks    = if (show_separators) "outside" else "",
    tickcolor = if (show_separators) "white" else NULL,
    tickwidth = if (show_separators) 2 else NULL,
    tickfont = list(size = tick_font_size),
    len = len,
    thickness = thickness
  )
  if (horizontal) {
    p$x$data[[idx]]$colorbar$orientation <- "h"
    p$x$data[[idx]]$colorbar$x <- 0.5
    p$x$data[[idx]]$colorbar$xanchor <- "center"
    p$x$data[[idx]]$colorbar$y <- -0.22
  }
  p
}

```

## Comparing Crime and Poverty by U.S. County 

```{r echo=FALSE, message=FALSE, warning=FALSE, error=FALSE}
#| column: page
#| fig-width: 22
#| fig-height: 30
#| fig-align: center
#| out-width: 100%
#| dpi: 220


df <- county

df <- derive_fips(df)

# Join metrics to polygons
map_df <- counties_poly %>%
  left_join(
    df %>% select(fips, all_of(county_metric_cols)),
    by = "fips"
  )

# Limits for each metric - 95th percentile as the upper scale limit
lim_pov  <- c(0, max(0.3, min(0.6, ceiling(p95(map_df$poverty_rate) * 10) / 10))) 
lim_prop <- c(0, p95(map_df$property_crime_per_100k)) 
lim_viol <- c(0, p95(map_df$violent_crime_per_100k)) 

poverty <- build_county_map(map_df) +
  geom_polygon(aes(fill = poverty_rate)) +
  scale_fill_binned_left(
    x = map_df$poverty_rate,
    step = 0.05, 
    min_cap = 0.30, max_cap = 0.60,
    label_fmt = scales::label_percent(accuracy = 1),
    name = "Poverty rate (% of residents)"
  ) +
  labs(title = "Poverty Rate by County") +
  theme(
    legend.position = "top",
    plot.title = element_text(size = 22, face = "bold"),
    plot.title.position = "plot",
    legend.justification = "left",
    legend.box.just = "left"
  )

property <- build_county_map(map_df) +
  geom_polygon(aes(fill = property_crime_per_100k)) +
  scale_fill_binned_left(
    x = map_df$property_crime_per_100k,
    step = 500,  # Bucket width
    label_fmt = scales::label_number(accuracy = 1, big.mark = ","),
    name = "Property crime (per 100k)"
  ) +
  labs(title = "Property Crime per 100,000") +
  theme(
    legend.position = "top",
    plot.title = element_text(size = 22, face = "bold"),
    plot.title.position = "plot",
    legend.justification = "left",
    legend.box.just = "left"
  )

violent <- build_county_map(map_df) +
  geom_polygon(aes(fill = violent_crime_per_100k)) +
  scale_fill_binned_left(
    x = map_df$violent_crime_per_100k,
    step = 100,
    label_fmt = scales::label_number(accuracy = 1, big.mark = ","),
    name = "Violent crime (per 100k)"
  ) +
  labs(title = "Violent Crime per 100,000") +
  theme(
    legend.position = "top",
    plot.title = element_text(size = 22, face = "bold"),
    plot.title.position = "plot",
    legend.justification = "left",
    legend.box.just = "left"
  )

# Stack each plot vertically
stack_us <-
  (poverty / property / violent) &
  theme(
    plot.margin = margin(6, 10, 6, 10)
  )

stack_us +
  plot_annotation(
    title   = "Crime & Poverty by U.S. County",
    caption = "Note: Some county data are missing from the Census data\nSource: FBI Crime Data API and data.census.gov for 2023",
    theme = theme(
      plot.title.position = "plot",
      plot.title   = element_text(size = 28, face = "bold", hjust = 0), 
      plot.caption.position = "plot", 
      plot.caption = element_text(size = 16, hjust = 0, colour = "grey30",
                                  lineheight = 1.15, margin = margin(t = 10)),
      plot.margin  = margin(8, 12, 18, 12)
    )
  )
```

## Zooming in on South Carolina

```{r echo=FALSE, message=FALSE, warning=FALSE, error=FALSE}
#| column: page
#| fig-width: 22
#| fig-height: 30
#| fig-align: center
#| out-width: 100%
#| dpi: 220

df <- county

df <- derive_fips(df)

# Build South Carolina map data only
sc_poly <- counties_poly %>% filter(region == "south carolina")

sc_map <- sc_poly %>%
  left_join(df %>% select(fips, all_of(county_metric_cols)), by = "fips")

lim_pov  <- c(0, max(0.3, min(0.6, ceiling(p95(sc_map$poverty_rate) * 10) / 10)))
lim_prop <- c(0, {x <- p95(sc_map$property_crime_per_100k); if (!is.finite(x)) max(sc_map$property_crime_per_100k, na.rm = TRUE) else x})
lim_viol <- c(0, {x <- p95(sc_map$violent_crime_per_100k);  if (!is.finite(x)) max(sc_map$violent_crime_per_100k,  na.rm = TRUE) else x})

poverty_sc <- build_county_map(sc_map) +
  geom_polygon(aes(fill = poverty_rate)) +
  scale_fill_binned_left(
    x = sc_map$poverty_rate,
    step = 0.05,
    min_cap = 0.30, max_cap = 0.60,
    label_fmt = scales::label_percent(accuracy = 1),
    name = "Poverty rate (% of residents)"
  ) +
  labs(title = "Poverty Rate by County") +
  theme(
    legend.position = "top",
    plot.title.position = "plot",
    legend.justification = "left",
    legend.box.just = "left",
    plot.title = element_text(size = 22, face = "bold")
  )

property_sc <- build_county_map(sc_map) +
  geom_polygon(aes(fill = property_crime_per_100k)) +
  scale_fill_binned_left(
    x = sc_map$property_crime_per_100k,
    step = 500,
    label_fmt = scales::label_number(accuracy = 1, big.mark = ","),
    name = "Property crime (per 100k residents)"
  ) +
  labs(title = "Property Crime per 100,000") +
  theme(
    legend.position = "top",
    plot.title.position = "plot",
    legend.justification = "left",
    legend.box.just = "left",
    plot.title = element_text(size = 22, face = "bold")
  )

violent_sc <- build_county_map(sc_map) +
  geom_polygon(aes(fill = violent_crime_per_100k)) +
  scale_fill_binned_left(
    x = sc_map$violent_crime_per_100k,
    step = 200,
    label_fmt = scales::label_number(accuracy = 1, big.mark = ","),
    name = "Violent crime (per 100k residents)"
  ) +
  labs(title = "Violent Crime per 100,000") +
  theme(
    legend.position = "top",
    plot.title.position = "plot",
    legend.justification = "left",
    legend.box.just = "left",
    plot.title = element_text(size = 22, face = "bold")
  )

# Stack the three maps
stack_sc <-
  (poverty_sc / property_sc / violent_sc) &
  theme(plot.margin = margin(6, 10, 6, 10))

stack_sc +
  plot_annotation(
    title   = "South Carolina by County",
    caption = "Note: Some county data are missing from the Census data\nSource: FBI Crime Data API and data.census.gov for 2023",
    theme = theme(
      plot.title.position = "plot",
      plot.title   = element_text(size = 28, face = "bold", hjust = 0),
      plot.caption.position = "plot",
      plot.caption = element_text(size = 16, hjust = 0, colour = "grey30",
                                  lineheight = 1.15, margin = margin(t = 10)),
      plot.margin  = margin(8, 12, 18, 12)
    )
  )

```

## Interactive Plot of South Carolina to Look at Individual Counties

```{r echo=FALSE, message=FALSE, warning=FALSE, error=FALSE}

df <- county

df <- derive_fips(df)

sc <- counties_poly %>%
  dplyr::filter(region == "south carolina") %>%
  dplyr::left_join(df %>% dplyr::select(fips, poverty_rate, property_crime_per_100k, violent_crime_per_100k),
                   by = "fips") %>%
  dplyr::mutate(
    hover_text = paste0(
      "County: ", stringr::str_to_title(subregion), "<br>",
      "Poverty rate: ", scales::percent(poverty_rate, accuracy = 0.1), "<br>",
      "Property /100k: ", scales::comma(property_crime_per_100k, accuracy = 1), "<br>",
      "Violent /100k: ",  scales::comma(violent_crime_per_100k,  accuracy = 1)
    )
  )

# --- bins to MATCH your static poverty maps (left-anchored, 5% steps, 30–60% cap) ---
step  <- 0.05
upper <- min(0.60, max(0.30, ceiling(p95(sc$poverty_rate) / step) * step))
brks  <- seq(0, upper, by = step)
labs  <- paste0(scales::percent(head(brks, -1), accuracy = 1), "–",
                scales::percent(tail(brks, -1), accuracy = 1))

# --- ggplot (legend off; Plotly will supply the colorbar) ---
p_sc <- ggplot(sc, aes(long, lat, group = group)) +
  geom_polygon(aes(fill = poverty_rate, text = hover_text), color = "gray85", linewidth = 0.1, na.rm = TRUE) +
  coord_quickmap() +
  scale_fill_viridis_b(
    option = "mako", begin = 0.15, end = 0.90, direction = -1,
    limits = range(brks),
    breaks = brks,                     # edges → left-anchored labels
    labels = c(labs, ""),              # empty right edge
    oob = scales::squish, na.value = "gray95",
    name = NULL, guide = "none"        # hide ggplot legend
  ) +
  labs(title = "South Carolina — Poverty Rate") +
  theme_void(base_size = 12)

# --- plotly conversion + enforced title + custom colorbar ---
p <- plotly::ggplotly(p_sc, tooltip = "text")
p <- plotly::layout(p, title = list(text = "South Carolina — Poverty Rate", x = 0, xanchor = "left"))

p <- apply_plotly_binned_colorbar(
  p,
  brks = brks,
  labs = labs,
  title = "Poverty rate (% of residents)",
  horizontal = TRUE,
  thickness = 28, len = 1, show_separators = TRUE,
  title_font_size = 13, tick_font_size = 12
)

p

```

